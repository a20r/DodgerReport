
\begin{document}

\chapter{Implementation}

\label{chapter:Implementation}

\section{Initial}

Due to the ease of development and the author's experience with the language,
Python was chosen as the initial language for the implementation. All three
attempts described in Ch.~\ref{chapter:design}, were implemented and a suite of
tests scripts and visualization mechanisms were created in order to
incrementally assess how each planner was behaving. However after the
implementation was completed for the final design described in
Sec.~\ref{sec:finaldesign}, it was discovered that Python could not produce
solution paths (without replanning) through dynamic environments in a real-time
scenario. Since Python could not search the graph within an acceptable amount
of time, it could only be used for \emph{a priori} planning and therefore could
not be used in stochastic environments in which replanning would be needed. Due
to this drawback, the author decided to rewrite the entire implementation in
C++.  Since this initial attempt is complete, it is publicly available
at~\cite{racer}.

\section{Final}

The final implementation was written in C++ due to the tremendous speed
improvement which made planning in real-time viable. Due to the object oriented
structure of C++, the planner and the associated data structures were
encapsulated in classes which made it very easy for people to use the code as
an API. While designing the software, extra effort was put into making the code
easily usable by other people who are not necessarily experts in robotics or
motion planning.  The system has an easy import mechanism and several examples
on how to use the different planners that have been implemented.

In order to visualize the paths that the planner has generated, the C++ code
can export the paths of the robot and the dynamic obstacles to a JSON file and
a Python script then can read and parse the generated JSON and display the
paths using either Matplotlib or RViz. Matplotlib is an open source library for
creating plots from data~\cite{matplotlib}. It is very similar to Matlab or
Mathematica except it runs natively in Python. RViz is a core component of the
Robotic Operating System (ROS) which can render dynamic scenes in three
dimensions and can visualize native geometrical and navigation messages from
ROS~\cite{ros}.  Since the paths are exported to JSON, a standard format with
parsers in many languages, third party software can be developed that can parse
the generated JSON file and analyze or visualize the generated paths.
Likewise, the Dodger library can be imported by a third party program to
control robots from the generated paths or to visualize the paths using other
visualization tools such as OpenGL. A diagram of this tool-chain is shown in
Fig.~\ref{fig:software}.

% change the below figure

\begin{figure}[h!]

    \centering

    \includegraphics[width=0.8\linewidth]{figs/toolchain}

    \caption{A diagram depicting the work flow for the implementation. The
    Dodger library can either generate a path and export to a JSON file which
can then be visualized in Matplotlib or RViz using one of the Python scripts
provided or user code can read the exported JSON to control robots or visualize
the paths. The library can also be imported by user code to either visualize
paths or control a robot with ROS.}

    \label{fig:software}

\end{figure}

By separating the visualization code completely from the planner code, the
software is more easily portable to different visualization frameworks and
ensures that the user does not need to have a certain graphical software or ROS
installed for the software to be able to compile and use the library. This
allowed the planner code to be entirely self contained and simple to compile
with a provided CMake file which compiles the C++ code into a static library.
Likewise, this design decision in the implementation allows the generated paths
to be saved and either analysed or visualized at another time.  Also, since the
planner had no dependencies, experiments could be run on the servers provided
without needing root access.  This code is also made publicly available
at~\cite{dodger}.

\end{document}
